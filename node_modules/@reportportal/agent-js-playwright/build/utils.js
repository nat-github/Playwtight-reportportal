"use strict";
/*
 *  Copyright 2022 EPAM Systems
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeParse = exports.calculateRpStatus = exports.isErrorLog = exports.getAttachments = exports.fileExists = exports.sendEventToReporter = exports.getCodeRef = exports.getSystemAttributes = exports.getAgentInfo = exports.promiseErrorHandler = exports.isFalse = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
// @ts-ignore
const package_json_1 = require("../package.json");
const constants_1 = require("./constants");
const test_1 = require("@playwright/test");
const fsPromises = fs_1.default.promises;
const isFalse = (value) => [false, 'false'].includes(value);
exports.isFalse = isFalse;
const promiseErrorHandler = (promise, message = '') => promise.catch((err) => {
    console.error(message, err);
});
exports.promiseErrorHandler = promiseErrorHandler;
const getAgentInfo = () => ({
    version: package_json_1.version,
    name: package_json_1.name,
});
exports.getAgentInfo = getAgentInfo;
const getSystemAttributes = (skippedIssue = true) => {
    const systemAttributes = [
        {
            key: 'agent',
            value: `${package_json_1.name}|${package_json_1.version}`,
            system: true,
        },
    ];
    if ((0, exports.isFalse)(skippedIssue)) {
        const skippedIssueAttribute = {
            key: 'skippedIssue',
            value: 'false',
            system: true,
        };
        systemAttributes.push(skippedIssueAttribute);
    }
    return systemAttributes;
};
exports.getSystemAttributes = getSystemAttributes;
const getCodeRef = (testItem, itemTitle, pathToExclude) => {
    if (!itemTitle) {
        return '';
    }
    const filteredTitlesPath = testItem
        .titlePath()
        .filter((itemPath) => itemPath !== '' && itemPath !== pathToExclude);
    const itemIndex = filteredTitlesPath.indexOf(itemTitle);
    return filteredTitlesPath
        .slice(0, itemIndex + 1)
        .join('/')
        .replace(new RegExp('\\'.concat(path_1.default.sep), 'g'), '/');
};
exports.getCodeRef = getCodeRef;
const sendEventToReporter = (type, data, suite) => {
    const annotation = {
        type: type,
        description: JSON.stringify(data),
    };
    if (suite) {
        process.stdout.write(JSON.stringify({ type, data, suite }));
    }
    else {
        test_1.test.info().annotations.push(annotation);
    }
};
exports.sendEventToReporter = sendEventToReporter;
const fileExists = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield fsPromises.stat(filePath);
        return true;
    }
    catch (error) {
        // ENOENT code - File does not exist
        if (error.code === 'ENOENT') {
            return false;
        }
        else {
            throw error;
        }
    }
});
exports.fileExists = fileExists;
const getAttachments = (attachments, { uploadTrace, uploadVideo } = { uploadTrace: true, uploadVideo: true }, testTitle) => __awaiter(void 0, void 0, void 0, function* () {
    const isTraceNotAllowed = (0, exports.isFalse)(uploadTrace);
    const isVideoNotAllowed = (0, exports.isFalse)(uploadVideo);
    const readFilePromises = attachments
        .filter(({ name, path: attachmentPath, contentType, body }) => {
        const isValidAttachment = body || attachmentPath;
        const ignoreAsTrace = isTraceNotAllowed &&
            name === constants_1.BASIC_ATTACHMENT_NAMES.TRACE &&
            contentType === constants_1.BASIC_ATTACHMENT_CONTENT_TYPES.TRACE;
        const ignoreAsVideo = isVideoNotAllowed &&
            name === constants_1.BASIC_ATTACHMENT_NAMES.VIDEO &&
            contentType === constants_1.BASIC_ATTACHMENT_CONTENT_TYPES.VIDEO;
        return isValidAttachment && !ignoreAsTrace && !ignoreAsVideo;
    })
        .map(({ name, path: attachmentPath, contentType, body }) => __awaiter(void 0, void 0, void 0, function* () {
        let fileContent;
        try {
            if (body) {
                fileContent = body;
            }
            else {
                const isFileExist = yield (0, exports.fileExists)(attachmentPath);
                if (!isFileExist) {
                    return;
                }
                fileContent = yield fsPromises.readFile(attachmentPath);
            }
        }
        catch (e) {
            console.error(e);
            return;
        }
        const attachmentName = testTitle
            ? testTitle
                .toLowerCase()
                .replace(/[^a-z0-9 _-]/g, '')
                .replace(/\s+/g, '-')
                .concat('_', name)
            : name;
        return {
            name: attachmentName,
            type: contentType,
            content: fileContent,
        };
    }));
    return (yield Promise.all(readFilePromises)).filter(Boolean);
});
exports.getAttachments = getAttachments;
const isErrorLog = (message) => {
    return message.toLowerCase().includes('error');
};
exports.isErrorLog = isErrorLog;
// https://playwright.dev/docs/api/class-testresult#test-result-status
const calculateRpStatus = (outcome, status, annotations) => {
    let calculatedStatus = constants_1.STATUSES.FAILED;
    switch (outcome) {
        case constants_1.TEST_OUTCOME_TYPES.EXPECTED:
            calculatedStatus = constants_1.STATUSES.PASSED;
            break;
        case constants_1.TEST_OUTCOME_TYPES.FLAKY:
            calculatedStatus = constants_1.STATUSES.PASSED;
            break;
        case constants_1.TEST_OUTCOME_TYPES.UNEXPECTED:
            if (annotations.some((annotation) => annotation.type === constants_1.TEST_ANNOTATION_TYPES.FAIL)) {
                calculatedStatus = status === constants_1.STATUSES.PASSED ? constants_1.STATUSES.FAILED : constants_1.STATUSES.PASSED;
            }
            break;
        case constants_1.TEST_OUTCOME_TYPES.SKIPPED:
            calculatedStatus = status === constants_1.STATUSES.INTERRUPTED ? constants_1.STATUSES.INTERRUPTED : constants_1.STATUSES.SKIPPED;
            break;
        default:
            break;
    }
    return calculatedStatus;
};
exports.calculateRpStatus = calculateRpStatus;
const safeParse = (input) => {
    if (typeof input !== 'string') {
        return input;
    }
    try {
        const parsed = JSON.parse(input);
        return parsed;
    }
    catch (_a) {
        return input;
    }
};
exports.safeParse = safeParse;
//# sourceMappingURL=utils.js.map